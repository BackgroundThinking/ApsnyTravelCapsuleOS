> # Error Handling & Logging Guide

**Version:** 1.0
**Date:** December 2, 2025

---

## 1. Overview

This guide describes the error handling and logging infrastructure in ApsnyTravelCapsuleOS. The application includes multiple layers of error handling to ensure robustness and provide meaningful feedback to users and developers.

---

## 2. Logging System

The application includes a structured logging system via the `logger` utility in `client/src/lib/logger.ts`.

### 2.1. Using the Logger

```typescript
import { logger, LogLevel } from "@/lib/logger";

// Log at different levels
logger.debug("Debug message", { data: "value" });
logger.info("Information message", { data: "value" });
logger.warn("Warning message", { data: "value" });
logger.error("Error message", error, { data: "value" });

// Set log level
logger.setLevel(LogLevel.DEBUG); // Show all logs
logger.setLevel(LogLevel.ERROR); // Show only errors

// Export logs for debugging
const logs = logger.exportLogs();
console.log(logs);
```

### 2.2. Log Levels

| Level   | Value | Description                                              |
| :------ | :---- | :------------------------------------------------------- |
| `DEBUG` | 0     | Detailed information for debugging.                      |
| `INFO`  | 1     | General informational messages.                          |
| `WARN`  | 2     | Warning messages for potentially problematic situations. |
| `ERROR` | 3     | Error messages for failures.                             |

By default, the application uses `DEBUG` level in development and `INFO` level in production.

---

## 3. Error Boundary

The application includes an `ErrorBoundary` component that catches errors in child components and displays a fallback UI.

### 3.1. Using Error Boundary

```typescript
import ErrorBoundary from "@/components/ErrorBoundary";

export function App() {
  return (
    <ErrorBoundary>
      <YourComponent />
    </ErrorBoundary>
  );
}
```

### 3.2. Custom Fallback UI

```typescript
<ErrorBoundary
  fallback={(error, reset) => (
    <div>
      <p>Something went wrong: {error.message}</p>
      <button onClick={reset}>Try Again</button>
    </div>
  )}
>
  <YourComponent />
</ErrorBoundary>
```

---

## 4. Data Fetching Error Handling

When fetching capsules or other data, always handle potential errors:

```typescript
import { fetchCapsules } from "@/lib/data";
import { logger } from "@/lib/logger";

async function loadCapsules() {
  try {
    const capsules = await fetchCapsules();
    logger.info("Capsules loaded successfully", { count: capsules.length });
    return capsules;
  } catch (error) {
    logger.error("Failed to load capsules", error);
    // Display user-friendly error message
    return [];
  }
}
```

---

## 5. Search Error Handling

The search module includes built-in error handling:

```typescript
import { capsuleSearch } from "@/lib/search";
import { logger } from "@/lib/logger";

async function performSearch(query: string) {
  try {
    await capsuleSearch.loadIndex();
    const results = capsuleSearch.search(query);
    logger.info("Search completed", { query, resultCount: results.length });
    return results;
  } catch (error) {
    logger.error("Search failed", error);
    return [];
  }
}
```

---

## 6. Best Practices

1. **Always log errors:** Use `logger.error()` for any caught exceptions.
2. **Provide context:** Include relevant data when logging to aid debugging.
3. **Use appropriate levels:** Use `warn` for potentially problematic situations, `error` for failures.
4. **Handle async errors:** Always use try-catch blocks for async operations.
5. **User-friendly messages:** Display user-friendly error messages instead of technical details.
6. **Monitor logs:** Regularly review logs to identify patterns and issues.

---

**Generated by:** Manus AI
